import { afterEach, describe, expect, it } from "vitest";
import type { HistoryEntry } from "../types";
import {
  buildConversationHistory,
  buildConversationText,
  buildExportText,
  type ExportFormat,
  generateSilenceBasedChapters,
  generateHybridChapters,
  generateTimeBasedChapters,
} from "../history";
import { setHistory, setTranscribeHistory } from "../state";

describe("history helpers", () => {
  afterEach(() => {
    setHistory([]);
    setTranscribeHistory([]);
  });

  it("combines and sorts input + output history by newest first", () => {
    const mic: HistoryEntry = {
      id: "mic-1",
      text: "Mic entry",
      timestamp_ms: 1000,
      source: "mic",
    };
    const system: HistoryEntry = {
      id: "sys-1",
      text: "System entry",
      timestamp_ms: 2000,
      source: "output",
    };

    setHistory([mic]);
    setTranscribeHistory([system]);

    const combined = buildConversationHistory();
    expect(combined).toHaveLength(2);
    expect(combined[0].id).toBe("sys-1");
    expect(combined[1].id).toBe("mic-1");
  });

  it("builds conversation text with speaker labels", () => {
    const entries: HistoryEntry[] = [
      {
        id: "a",
        text: "Hello",
        timestamp_ms: 1000,
        source: "mic",
      },
      {
        id: "b",
        text: "World",
        timestamp_ms: 2000,
        source: "output",
      },
    ];

    const text = buildConversationText(entries);
    expect(text).toContain("Input: Hello");
    expect(text).toContain("Output: World");
    expect(text).toContain("\n");
    expect(text.trim().startsWith("[")).toBe(true);
  });
});

describe("export serialization", () => {
  const mockEntries: HistoryEntry[] = [
    {
      id: "entry-1",
      text: "First entry from microphone",
      timestamp_ms: 1000,
      source: "mic",
    },
    {
      id: "entry-2",
      text: "Second entry from system audio",
      timestamp_ms: 2000,
      source: "output",
    },
    {
      id: "entry-3",
      text: "Third entry from microphone",
      timestamp_ms: 3000,
      source: "mic",
    },
  ];

  describe("buildExportText - TXT format", () => {
    it("generates valid TXT export with header and entries", () => {
      const txt = buildExportText(mockEntries, "txt");

      // Check header
      expect(txt).toContain("Trispr Flow - Transcript Export");
      expect(txt).toContain("Date:");
      expect(txt).toContain("Entries: 3");

      // Check entries
      expect(txt).toContain("Input: First entry from microphone");
      expect(txt).toContain("Output: Second entry from system audio");
      expect(txt).toContain("Input: Third entry from microphone");

      // Check chronological order (oldest to newest)
      const lines = txt.split("\n");
      const entryLines = lines.filter((line) => line.includes("Input:") || line.includes("Output:"));
      expect(entryLines[0]).toContain("First entry");
      expect(entryLines[1]).toContain("Second entry");
      expect(entryLines[2]).toContain("Third entry");
    });

    it("handles empty entries array", () => {
      const txt = buildExportText([], "txt");
      expect(txt).toContain("Entries: 0");
      expect(txt.split("\n").filter((line) => line.includes("Input:") || line.includes("Output:"))).toHaveLength(0);
    });
  });

  describe("buildExportText - Markdown format", () => {
    it("generates valid Markdown export with sections", () => {
      const md = buildExportText(mockEntries, "md");

      // Check header
      expect(md).toContain("# Transcript Export");
      expect(md).toContain("**Date**:");
      expect(md).toContain("**Total Entries**: 3");

      // Check sections
      expect(md).toContain("## Input Transcription");
      expect(md).toContain("## Output Transcription");

      // Check entries formatted as lists
      expect(md).toMatch(/- \*\*.*\*\*: First entry from microphone/);
      expect(md).toMatch(/- \*\*.*\*\* \(Output\): Second entry from system audio/);

      // Check footer
      expect(md).toContain("*Generated by Trispr Flow*");
    });

    it("separates input and output entries into sections", () => {
      const md = buildExportText(mockEntries, "md");
      const sections = md.split("## ");

      // Find input and output sections
      const inputSection = sections.find((s) => s.startsWith("Input Transcription"));
      const outputSection = sections.find((s) => s.startsWith("Output Transcription"));

      expect(inputSection).toBeDefined();
      expect(outputSection).toBeDefined();

      // Input section should have 2 entries
      expect(inputSection?.match(/- \*\*/g)?.length).toBe(2);
      // Output section should have 1 entry
      expect(outputSection?.match(/- \*\*/g)?.length).toBe(1);
    });

    it("handles only input entries", () => {
      const inputOnly: HistoryEntry[] = [
        { id: "1", text: "Test", timestamp_ms: 1000, source: "mic" },
      ];
      const md = buildExportText(inputOnly, "md");

      expect(md).toContain("## Input Transcription");
      expect(md).not.toContain("## Output Transcription");
    });

    it("handles only output entries", () => {
      const outputOnly: HistoryEntry[] = [
        { id: "1", text: "Test", timestamp_ms: 1000, source: "output" },
      ];
      const md = buildExportText(outputOnly, "md");

      expect(md).toContain("## Output Transcription");
      expect(md).not.toContain("## Input Transcription");
    });
  });

  describe("buildExportText - JSON format", () => {
    it("generates valid JSON with correct structure", () => {
      const jsonStr = buildExportText(mockEntries, "json");
      const json = JSON.parse(jsonStr);

      // Check top-level fields
      expect(json).toHaveProperty("export_date");
      expect(json).toHaveProperty("format_version", "1.0");
      expect(json).toHaveProperty("entry_count", 3);
      expect(json).toHaveProperty("entries");

      // Validate export_date is ISO 8601
      expect(() => new Date(json.export_date)).not.toThrow();
    });

    it("includes all entry fields in JSON format", () => {
      const jsonStr = buildExportText(mockEntries, "json");
      const json = JSON.parse(jsonStr);

      expect(json.entries).toHaveLength(3);

      const firstEntry = json.entries[0];
      expect(firstEntry).toHaveProperty("id", "entry-1");
      expect(firstEntry).toHaveProperty("timestamp_ms", 1000);
      expect(firstEntry).toHaveProperty("timestamp");
      expect(firstEntry).toHaveProperty("source", "mic");
      expect(firstEntry).toHaveProperty("text", "First entry from microphone");

      // Validate timestamp is ISO 8601
      expect(() => new Date(firstEntry.timestamp)).not.toThrow();
    });

    it("preserves entry order (oldest to newest)", () => {
      const jsonStr = buildExportText(mockEntries, "json");
      const json = JSON.parse(jsonStr);

      expect(json.entries[0].id).toBe("entry-1");
      expect(json.entries[1].id).toBe("entry-2");
      expect(json.entries[2].id).toBe("entry-3");
    });

    it("handles empty entries array in JSON", () => {
      const jsonStr = buildExportText([], "json");
      const json = JSON.parse(jsonStr);

      expect(json.entry_count).toBe(0);
      expect(json.entries).toEqual([]);
    });

    it("produces valid, parseable JSON", () => {
      const jsonStr = buildExportText(mockEntries, "json");
      expect(() => JSON.parse(jsonStr)).not.toThrow();
    });

    it("formats JSON with proper indentation", () => {
      const jsonStr = buildExportText(mockEntries, "json");
      // Check for 2-space indentation (JSON.stringify with null, 2)
      expect(jsonStr).toContain('  "export_date"');
      expect(jsonStr).toContain('  "format_version"');
    });
  });

  describe("format validation", () => {
    it("returns empty string for unknown format", () => {
      const result = buildExportText(mockEntries, "invalid" as ExportFormat);
      expect(result).toBe("");
    });

    it("handles format case-sensitivity correctly", () => {
      const txt = buildExportText(mockEntries, "txt");
      const md = buildExportText(mockEntries, "md");
      const json = buildExportText(mockEntries, "json");

      expect(txt).not.toBe("");
      expect(md).not.toBe("");
      expect(json).not.toBe("");
    });
  });

  describe("edge cases", () => {
    it("handles special characters in text", () => {
      const specialEntries: HistoryEntry[] = [
        {
          id: "1",
          text: "Text with \"quotes\" and 'apostrophes'",
          timestamp_ms: 1000,
          source: "mic",
        },
        {
          id: "2",
          text: "Text with <html> & special chars: Ã©, Ã±, Ã¼",
          timestamp_ms: 2000,
          source: "output",
        },
      ];

      const txt = buildExportText(specialEntries, "txt");
      const md = buildExportText(specialEntries, "md");
      const jsonStr = buildExportText(specialEntries, "json");

      // All formats should preserve special characters
      expect(txt).toContain('"quotes"');
      expect(md).toContain('<html>');
      expect(jsonStr).toContain('&');

      // JSON should be parseable
      expect(() => JSON.parse(jsonStr)).not.toThrow();
    });

    it("handles very long text entries", () => {
      const longText = "A".repeat(10000);
      const longEntries: HistoryEntry[] = [
        {
          id: "1",
          text: longText,
          timestamp_ms: 1000,
          source: "mic",
        },
      ];

      const txt = buildExportText(longEntries, "txt");
      const md = buildExportText(longEntries, "md");
      const jsonStr = buildExportText(longEntries, "json");

      expect(txt).toContain(longText);
      expect(md).toContain(longText);
      expect(JSON.parse(jsonStr).entries[0].text).toBe(longText);
    });

    it("handles entries with newlines in text", () => {
      const multilineEntries: HistoryEntry[] = [
        {
          id: "1",
          text: "Line 1\nLine 2\nLine 3",
          timestamp_ms: 1000,
          source: "mic",
        },
      ];

      const txt = buildExportText(multilineEntries, "txt");
      const md = buildExportText(multilineEntries, "md");
      const jsonStr = buildExportText(multilineEntries, "json");

      // Text should preserve newlines
      expect(txt).toContain("Line 1\nLine 2");
      expect(md).toContain("Line 1\nLine 2");

      // JSON should escape newlines correctly
      const json = JSON.parse(jsonStr);
      expect(json.entries[0].text).toBe("Line 1\nLine 2\nLine 3");
    });
  });
});

describe("chapter generation", () => {
  describe("generateSilenceBasedChapters", () => {
    it("creates chapters based on silence gaps", () => {
      const entries: HistoryEntry[] = [
        { id: "1", text: "Entry 1", timestamp_ms: 1000, source: "mic" },
        { id: "2", text: "Entry 2", timestamp_ms: 1500, source: "mic" },
        // 3 second gap (silence)
        { id: "3", text: "Entry 3", timestamp_ms: 4500, source: "mic" },
        { id: "4", text: "Entry 4", timestamp_ms: 5000, source: "mic" },
        // 2.5 second gap (silence)
        { id: "5", text: "Entry 5", timestamp_ms: 7500, source: "mic" },
      ];

      const chapters = generateSilenceBasedChapters(entries, 2000);

      expect(chapters).toHaveLength(3);
      expect(chapters[0].entry_count).toBe(2); // Entries 1-2
      expect(chapters[1].entry_count).toBe(2); // Entries 3-4
      expect(chapters[2].entry_count).toBe(1); // Entry 5
    });

    it("uses default 2s threshold when not specified", () => {
      const entries: HistoryEntry[] = [
        { id: "1", text: "Entry 1", timestamp_ms: 1000, source: "mic" },
        { id: "2", text: "Entry 2", timestamp_ms: 2000, source: "mic" },
        // 2.1 second gap (just over threshold)
        { id: "3", text: "Entry 3", timestamp_ms: 4100, source: "mic" },
      ];

      const chapters = generateSilenceBasedChapters(entries);

      expect(chapters).toHaveLength(2);
      expect(chapters[0].entry_count).toBe(2);
      expect(chapters[1].entry_count).toBe(1);
    });

    it("creates single chapter when no silence gaps exceed threshold", () => {
      const entries: HistoryEntry[] = [
        { id: "1", text: "Entry 1", timestamp_ms: 1000, source: "mic" },
        { id: "2", text: "Entry 2", timestamp_ms: 1500, source: "mic" },
        { id: "3", text: "Entry 3", timestamp_ms: 2000, source: "mic" },
      ];

      const chapters = generateSilenceBasedChapters(entries, 2000);

      expect(chapters).toHaveLength(1);
      expect(chapters[0].entry_count).toBe(3);
    });

    it("handles empty entries array", () => {
      const chapters = generateSilenceBasedChapters([]);
      expect(chapters).toEqual([]);
    });

    it("handles single entry", () => {
      const entries: HistoryEntry[] = [
        { id: "1", text: "Only entry", timestamp_ms: 1000, source: "mic" },
      ];

      const chapters = generateSilenceBasedChapters(entries);

      expect(chapters).toHaveLength(1);
      expect(chapters[0].entry_count).toBe(1);
      expect(chapters[0].timestamp_ms).toBe(1000);
    });

    it("sets chapter timestamps to first entry of each chapter", () => {
      const entries: HistoryEntry[] = [
        { id: "1", text: "Entry 1", timestamp_ms: 1000, source: "mic" },
        { id: "2", text: "Entry 2", timestamp_ms: 1500, source: "mic" },
        // Silence gap
        { id: "3", text: "Entry 3", timestamp_ms: 5000, source: "mic" },
      ];

      const chapters = generateSilenceBasedChapters(entries, 2000);

      expect(chapters[0].timestamp_ms).toBe(1000); // First chapter starts at entry 1
      expect(chapters[1].timestamp_ms).toBe(5000); // Second chapter starts at entry 3
    });

    it("generates unique chapter IDs", () => {
      const entries: HistoryEntry[] = [
        { id: "1", text: "Entry 1", timestamp_ms: 1000, source: "mic" },
        { id: "2", text: "Entry 2", timestamp_ms: 5000, source: "mic" },
        { id: "3", text: "Entry 3", timestamp_ms: 10000, source: "mic" },
      ];

      const chapters = generateSilenceBasedChapters(entries, 2000);

      expect(chapters[0].id).toBe("chapter-silence-1");
      expect(chapters[1].id).toBe("chapter-silence-2");
      expect(chapters[2].id).toBe("chapter-silence-3");
    });
  });

  describe("generateHybridChapters", () => {
    it("creates chapters based on both silence and max duration", () => {
      const entries: HistoryEntry[] = [
        { id: "1", text: "Entry 1", timestamp_ms: 0, source: "mic" },
        { id: "2", text: "Entry 2", timestamp_ms: 1000, source: "mic" },
        // 3s gap (silence trigger)
        { id: "3", text: "Entry 3", timestamp_ms: 4000, source: "mic" },
        { id: "4", text: "Entry 4", timestamp_ms: 5000, source: "mic" },
        // Long duration (11 minutes total) - should force break
        { id: "5", text: "Entry 5", timestamp_ms: 15 * 60 * 1000, source: "mic" },
      ];

      const chapters = generateHybridChapters(entries, 2000, 10 * 60 * 1000);

      expect(chapters.length).toBeGreaterThanOrEqual(2);
    });

    it("respects max chapter duration parameter", () => {
      const maxDuration = 5000; // 5 seconds
      const entries: HistoryEntry[] = [
        { id: "1", text: "Entry 1", timestamp_ms: 0, source: "mic" },
        { id: "2", text: "Entry 2", timestamp_ms: 1000, source: "mic" },
        { id: "3", text: "Entry 3", timestamp_ms: 2000, source: "mic" },
        // 6 seconds total - exceeds max duration
        { id: "4", text: "Entry 4", timestamp_ms: 6000, source: "mic" },
      ];

      const chapters = generateHybridChapters(entries, 10000, maxDuration);

      expect(chapters).toHaveLength(2);
    });

    it("uses default parameters when not specified", () => {
      const entries: HistoryEntry[] = [
        { id: "1", text: "Entry 1", timestamp_ms: 1000, source: "mic" },
        { id: "2", text: "Entry 2", timestamp_ms: 2000, source: "mic" },
      ];

      const chapters = generateHybridChapters(entries);

      expect(chapters).toHaveLength(1); // No silence gaps or duration exceeded
    });

    it("prevents single-entry chapters from duration breaks", () => {
      const entries: HistoryEntry[] = [
        { id: "1", text: "Entry 1", timestamp_ms: 0, source: "mic" },
        // Very long gap but only 1 entry in chapter so far
        { id: "2", text: "Entry 2", timestamp_ms: 20 * 60 * 1000, source: "mic" },
      ];

      const chapters = generateHybridChapters(entries, 2000, 10 * 60 * 1000);

      // Should create chapters, but first chapter shouldn't force-break with only 1 entry
      expect(chapters.length).toBeGreaterThanOrEqual(1);
    });

    it("handles empty entries array", () => {
      const chapters = generateHybridChapters([]);
      expect(chapters).toEqual([]);
    });
  });

  describe("generateTimeBasedChapters", () => {
    it("creates chapters at fixed time intervals", () => {
      const entries: HistoryEntry[] = [
        { id: "1", text: "Entry 1", timestamp_ms: 0, source: "mic" },
        { id: "2", text: "Entry 2", timestamp_ms: 1000, source: "mic" },
        // 5 minute mark
        { id: "3", text: "Entry 3", timestamp_ms: 5 * 60 * 1000, source: "mic" },
        { id: "4", text: "Entry 4", timestamp_ms: 6 * 60 * 1000, source: "mic" },
        // 10 minute mark
        { id: "5", text: "Entry 5", timestamp_ms: 10 * 60 * 1000, source: "mic" },
      ];

      const chapters = generateTimeBasedChapters(entries, 5);

      expect(chapters).toHaveLength(3);
      expect(chapters[0].entry_count).toBe(2); // 0-5 min
      expect(chapters[1].entry_count).toBe(2); // 5-10 min
      expect(chapters[2].entry_count).toBe(1); // 10+ min
    });

    it("uses default 5 minute interval when not specified", () => {
      const entries: HistoryEntry[] = [
        { id: "1", text: "Entry 1", timestamp_ms: 0, source: "mic" },
        { id: "2", text: "Entry 2", timestamp_ms: 6 * 60 * 1000, source: "mic" },
      ];

      const chapters = generateTimeBasedChapters(entries);

      expect(chapters).toHaveLength(2);
    });

    it("handles entries within single interval", () => {
      const entries: HistoryEntry[] = [
        { id: "1", text: "Entry 1", timestamp_ms: 0, source: "mic" },
        { id: "2", text: "Entry 2", timestamp_ms: 1000, source: "mic" },
        { id: "3", text: "Entry 3", timestamp_ms: 2000, source: "mic" },
      ];

      const chapters = generateTimeBasedChapters(entries, 5);

      expect(chapters).toHaveLength(1);
      expect(chapters[0].entry_count).toBe(3);
    });
  });

  describe("End-to-End Integration Tests", () => {
    describe("Complete Export Workflow", () => {
      it("exports realistic conversation in all formats", () => {
        const conversation: HistoryEntry[] = [
          {
            id: "e1",
            text: "Hello, I need help with a code bug in my API.",
            timestamp_ms: 1708000000000,
            source: "mic",
          },
          {
            id: "e2",
            text: "Sure, what seems to be the problem?",
            timestamp_ms: 1708000005000,
            source: "output",
          },
          {
            id: "e3",
            text: "The function returns undefined when I call it.",
            timestamp_ms: 1708000015000,
            source: "mic",
          },
          {
            id: "e4",
            text: "Let me check the error logs. Can you send the debug output?",
            timestamp_ms: 1708000025000,
            source: "output",
          },
          {
            id: "e5",
            text: "Here's the error: TypeError at line 42. The variable is null.",
            timestamp_ms: 1708000040000,
            source: "mic",
          },
        ];

        // Test TXT export
        const txtExport = buildExportText(conversation, "txt");
        expect(txtExport).toContain("Trispr Flow - Transcript Export");
        expect(txtExport).toContain("Entries: 5");
        expect(txtExport).toContain("Hello, I need help with a code bug");
        expect(txtExport).toContain("TypeError at line 42");

        // Test Markdown export
        const mdExport = buildExportText(conversation, "md");
        expect(mdExport).toContain("# Transcript Export");
        expect(mdExport).toContain("**Total Entries**: 5");
        expect(mdExport).toContain("## Input Transcription");
        expect(mdExport).toContain("## Output Transcription");
        expect(mdExport).toContain("*Generated by Trispr Flow*");

        // Test JSON export
        const jsonExport = buildExportText(conversation, "json");
        const parsed = JSON.parse(jsonExport);
        expect(parsed.format_version).toBe("1.0");
        expect(parsed.entry_count).toBe(5);
        expect(parsed.entries).toHaveLength(5);
        expect(parsed.entries[0].source).toBe("mic");
        expect(parsed.entries[1].source).toBe("output");
        expect(parsed.entries[4].text).toContain("TypeError at line 42");
      });

      it("handles mixed sources correctly", () => {
        const entries: HistoryEntry[] = [
          { id: "1", text: "Input text", timestamp_ms: 1000, source: "mic" },
          { id: "2", text: "Output text", timestamp_ms: 2000, source: "output" },
          { id: "3", text: "Local text", timestamp_ms: 3000, source: "local" },
          { id: "4", text: "Cloud text", timestamp_ms: 4000, source: "cloud" },
        ];

        const txtExport = buildExportText(entries, "txt");
        expect(txtExport).toContain("Input:");
        expect(txtExport).toContain("Output:");

        const jsonExport = buildExportText(entries, "json");
        const parsed = JSON.parse(jsonExport);
        expect(parsed.entries.map((e: { source: string }) => e.source)).toEqual([
          "mic",
          "output",
          "local",
          "cloud",
        ]);
      });

      it("preserves timestamps across formats", () => {
        const timestampMs = 1708000000000;
        const entries: HistoryEntry[] = [
          { id: "1", text: "Test", timestamp_ms: timestampMs, source: "mic" },
        ];

        const jsonExport = buildExportText(entries, "json");
        const parsed = JSON.parse(jsonExport);
        expect(parsed.entries[0].timestamp_ms).toBe(timestampMs);
        expect(parsed.entries[0].timestamp).toBe(new Date(timestampMs).toISOString());
      });
    });

    describe("Chapter + Export Integration", () => {
      it("generates chapters and exports with metadata", () => {
        const entries: HistoryEntry[] = [
          { id: "1", text: "First entry", timestamp_ms: 0, source: "mic" },
          { id: "2", text: "Second entry", timestamp_ms: 1000, source: "mic" },
          { id: "3", text: "Gap entry", timestamp_ms: 5000, source: "mic" }, // 4s gap
          { id: "4", text: "Fourth entry", timestamp_ms: 6000, source: "mic" },
        ];

        // Generate silence-based chapters
        const chapters = generateSilenceBasedChapters(entries, 2000);
        expect(chapters).toHaveLength(2);

        // Export with chapters available
        const jsonExport = buildExportText(entries, "json");
        const parsed = JSON.parse(jsonExport);
        expect(parsed.entries).toHaveLength(4);

        // Verify chapter structure (chapters only have entry_count, not entries array)
        expect(chapters[0].entry_count).toBe(2);
        expect(chapters[1].entry_count).toBe(2);
      });

      it("hybrid chapters handle max duration correctly", () => {
        const entries: HistoryEntry[] = [];
        const baseTime = Date.now();

        // Create entries spanning 25 minutes (should trigger max duration split)
        for (let i = 0; i < 10; i++) {
          entries.push({
            id: `e${i}`,
            text: `Entry ${i}`,
            timestamp_ms: baseTime + i * 3 * 60 * 1000, // 3 min intervals
            source: "mic",
          });
        }

        const chapters = generateHybridChapters(entries, 2000, 10 * 60 * 1000); // 10 min max
        expect(chapters.length).toBeGreaterThan(2); // Should split into multiple chapters

        // Export and verify
        const jsonExport = buildExportText(entries, "json");
        const parsed = JSON.parse(jsonExport);
        expect(parsed.entry_count).toBe(10);
      });
    });

    describe("Topic Detection Integration", () => {
      it("detects topics in realistic transcript", () => {
        const entries: HistoryEntry[] = [
          {
            id: "1",
            text: "We need to fix the API error in the database connection.",
            timestamp_ms: 1000,
            source: "mic",
          },
          {
            id: "2",
            text: "Let's schedule a meeting to discuss the agenda tomorrow.",
            timestamp_ms: 2000,
            source: "output",
          },
          {
            id: "3",
            text: "Reminder: follow-up on the personal note from yesterday.",
            timestamp_ms: 3000,
            source: "mic",
          },
        ];

        // Verify topic detection works
        const topicsMap = entries.reduce(
          (acc, entry) => {
            const topics: string[] = [];
            const text = entry.text.toLowerCase();

            if (/\b(api|error|database)\b/.test(text)) topics.push("technical");
            if (/\b(meeting|discuss|agenda)\b/.test(text)) topics.push("meeting");
            if (/\b(reminder|follow-up|personal|note)\b/.test(text)) topics.push("personal");

            acc[entry.id] = topics;
            return acc;
          },
          {} as Record<string, string[]>
        );

        expect(topicsMap["1"]).toContain("technical");
        expect(topicsMap["2"]).toContain("meeting");
        expect(topicsMap["3"]).toContain("personal");
      });
    });

    describe("Full Pipeline: Capture â†’ Process â†’ Export", () => {
      it("simulates complete user workflow", () => {
        // Step 1: Simulate captured entries (input + output)
        const capturedEntries: HistoryEntry[] = [
          { id: "c1", text: "Start meeting", timestamp_ms: 1000, source: "mic" },
          { id: "c2", text: "Acknowledged", timestamp_ms: 2000, source: "output" },
          { id: "c3", text: "Discuss technical bug", timestamp_ms: 5000, source: "mic" },
          { id: "c4", text: "Noted", timestamp_ms: 6000, source: "output" },
        ];

        // Step 2: Generate chapters
        const chapters = generateSilenceBasedChapters(capturedEntries, 2000);
        expect(chapters).toHaveLength(2); // Gap at 3s creates 2 chapters

        // Step 3: Verify entries are processable (sorted by timestamp)
        const sortedEntries = [...capturedEntries].sort((a, b) => a.timestamp_ms - b.timestamp_ms);
        expect(sortedEntries).toHaveLength(4);

        // Step 4: Export in all formats
        const formats: ExportFormat[] = ["txt", "md", "json"];
        formats.forEach((format) => {
          const exported = buildExportText(capturedEntries, format);
          expect(exported.length).toBeGreaterThan(0);

          if (format === "json") {
            const parsed = JSON.parse(exported);
            expect(parsed.entry_count).toBe(4);
            expect(parsed.entries).toHaveLength(4);
          }
        });

        // Step 5: Verify chapter metadata
        expect(chapters[0].entry_count).toBe(2);
        expect(chapters[1].entry_count).toBe(2);
        expect(chapters[0].id).toBe("chapter-silence-1");
        expect(chapters[1].id).toBe("chapter-silence-2");
      });

      it("handles large transcript export performance", () => {
        // Create a large transcript (1000 entries)
        const largeTranscript: HistoryEntry[] = [];
        for (let i = 0; i < 1000; i++) {
          largeTranscript.push({
            id: `large-${i}`,
            text: `This is entry number ${i} with some content that simulates real speech.`,
            timestamp_ms: i * 1000, // 1 second apart
            source: i % 2 === 0 ? "mic" : "output",
          });
        }

        // Verify export completes in reasonable time
        const startTime = performance.now();
        const jsonExport = buildExportText(largeTranscript, "json");
        const endTime = performance.now();

        expect(endTime - startTime).toBeLessThan(1000); // Should complete in <1s
        expect(jsonExport.length).toBeGreaterThan(10000); // Substantial content

        const parsed = JSON.parse(jsonExport);
        expect(parsed.entry_count).toBe(1000);
        expect(parsed.entries).toHaveLength(1000);
      });
    });

    describe("Error Recovery and Edge Cases", () => {
      it("gracefully handles malformed timestamps", () => {
        const entries: HistoryEntry[] = [
          { id: "1", text: "Valid entry", timestamp_ms: 1000, source: "mic" },
          { id: "2", text: "Future entry", timestamp_ms: Date.now() + 1000000, source: "mic" },
        ];

        const jsonExport = buildExportText(entries, "json");
        const parsed = JSON.parse(jsonExport);
        expect(parsed.entries).toHaveLength(2);
      });

      it("handles UTF-8 special characters correctly", () => {
        const entries: HistoryEntry[] = [
          { id: "1", text: "Emoji test: ðŸŽ¤ ðŸ”Š ðŸ“", timestamp_ms: 1000, source: "mic" },
          { id: "2", text: "Unicode: ã“ã‚“ã«ã¡ã¯ ä½ å¥½ Ù…Ø±Ø­Ø¨Ø§", timestamp_ms: 2000, source: "mic" },
          { id: "3", text: "Symbols: â‚¬ Â£ Â¥ Â© Â®", timestamp_ms: 3000, source: "mic" },
        ];

        const txtExport = buildExportText(entries, "txt");
        expect(txtExport).toContain("ðŸŽ¤ ðŸ”Š ðŸ“");
        expect(txtExport).toContain("ã“ã‚“ã«ã¡ã¯");
        expect(txtExport).toContain("â‚¬ Â£ Â¥");

        const jsonExport = buildExportText(entries, "json");
        const parsed = JSON.parse(jsonExport);
        expect(parsed.entries[0].text).toContain("ðŸŽ¤");
        expect(parsed.entries[1].text).toContain("ã“ã‚“ã«ã¡ã¯");
      });

      it("handles conversation with only input entries", () => {
        const entries: HistoryEntry[] = [
          { id: "1", text: "Input 1", timestamp_ms: 1000, source: "mic" },
          { id: "2", text: "Input 2", timestamp_ms: 2000, source: "mic" },
          { id: "3", text: "Input 3", timestamp_ms: 3000, source: "mic" },
        ];

        const mdExport = buildExportText(entries, "md");
        expect(mdExport).toContain("## Input Transcription");
        expect(mdExport).not.toContain("## Output Transcription");
      });

      it("handles conversation with only output entries", () => {
        const entries: HistoryEntry[] = [
          { id: "1", text: "Output 1", timestamp_ms: 1000, source: "output" },
          { id: "2", text: "Output 2", timestamp_ms: 2000, source: "output" },
        ];

        const mdExport = buildExportText(entries, "md");
        expect(mdExport).toContain("## Output Transcription");
        expect(mdExport).not.toContain("## Input Transcription");
      });
    });
  });
});
